<!DOCTYPE HTML>
<html lang="zh-hans">
<head>
<meta charset="utf-8"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>监督学习_决策树 · 机器学习相关学习记录</title>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="" name="description"/>
<meta content="GitBook 3.2.3" name="generator"/>
<meta content="narutohyc" name="author"/>
<link href="../gitbook/style.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-splitter/splitter.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-anchors/plugin.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-donate/plugin.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-anchor-navigation-ex/style/plugin.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-mermaid-gb3/mermaid/mermaid.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-tbfed-pagefooter/footer.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-code/plugin.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-search-plus/search.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-lightbox/css/lightbox.min.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-change_girls/girls.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-pageview-count/plugin.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-highlight/website.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-fontsettings/website.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-theme-comscore/test.css" rel="stylesheet"/>
<meta content="true" name="HandheldFriendly"/>
<meta content="width=device-width, initial-scale=1, user-scalable=no" name="viewport"/>
<meta content="yes" name="apple-mobile-web-app-capable"/>
<meta content="black" name="apple-mobile-web-app-status-bar-style"/>
<link href="../gitbook/images/apple-touch-icon-precomposed-152.png" rel="apple-touch-icon-precomposed" sizes="152x152"/>
<link href="../gitbook/images/favicon.ico" rel="shortcut icon" type="image/x-icon"/>
<link href="监督学习_K近邻法.html" rel="next"/>
<link href="监督学习_朴素贝叶斯分类.html" rel="prev"/>
<link href="./chapters/res/other/favicon.ico" rel="shortcut icon" type="image/x-icon"/>
<link href="./chapters/res/other/favicon.ico" rel="apple-touch-icon-precomposed" sizes="152x152"/>
<link href="../https:/upload-images.jianshu.io/upload_images/15675864-5e5ba668035853d8.png" rel="shortcut icon" type="image/x-icon"/>
<link href="../https:/upload-images.jianshu.io/upload_images/15675864-5e5ba668035853d8.png" rel="bookmark" type="image/x-icon"/>
<link href="../https:/upload-images.jianshu.io/upload_images/15675864-5e5ba668035853d8.png" rel="apple-touch-icon"/>
<link href="../https:/upload-images.jianshu.io/upload_images/15675864-5e5ba668035853d8.png" rel="apple-touch-icon" sizes="120x120"/>
<link href="../https:/upload-images.jianshu.io/upload_images/15675864-5e5ba668035853d8.png" rel="apple-touch-icon" sizes="180x180"/>
<style>
    @media only screen and (max-width: 640px) {
        .book-header .hidden-mobile {
            display: none;
        }
    }
    </style>
<script>
        window["gitbook-plugin-github-buttons"] = {"buttons":[{"user":"narutohyc","repo":"bk_machineLearning","type":"star","size":"small","count":true}]};
    </script>
</head>
<body>
<div class="book">
<div class="book-summary">
<div id="book-search-input" role="search">
<input placeholder="输入并搜索" type="text"/>
</div>
<nav role="navigation">
<ul class="summary">
<li>
<a class="custom-link" href="https://github.com/narutohyc" target="_blank">我的狗窝</a>
</li>
<li class="divider"></li>
<li class="chapter" data-level="1.1" data-path="../">
<a href="../">
<b>1.1.</b>
                    
                    Introduction
            
                </a>
</li>
<li class="chapter" data-level="1.2" data-path="机器学习基础.html">
<a href="机器学习基础.html">
<b>1.2.</b>
                    
                    机器学习基础
            
                </a>
<ul class="articles">
<li class="chapter" data-level="1.2.1" data-path="机器学习基础_距离.html">
<a href="机器学习基础_距离.html">
<b>1.2.1.</b>
                    
                    机器学习基础_距离
            
                </a>
</li>
<li class="chapter" data-level="1.2.2" data-path="机器学习基础_概率论基础.html">
<a href="机器学习基础_概率论基础.html">
<b>1.2.2.</b>
                    
                    机器学习基础_概率论基础
            
                </a>
</li>
<li class="chapter" data-level="1.2.3" data-path="机器学习基础_线性代数基础.html">
<a href="机器学习基础_线性代数基础.html">
<b>1.2.3.</b>
                    
                    机器学习基础_线性代数基础
            
                </a>
</li>
<li class="chapter" data-level="1.2.4" data-path="机器学习基础_微积分基础.html">
<a href="机器学习基础_微积分基础.html">
<b>1.2.4.</b>
                    
                    机器学习基础_微积分基础
            
                </a>
</li>
<li class="chapter" data-level="1.2.5" data-path="机器学习基础_最优化理论.html">
<a href="机器学习基础_最优化理论.html">
<b>1.2.5.</b>
                    
                    机器学习基础_最优化理论
            
                </a>
</li>
<li class="chapter" data-level="1.2.6" data-path="机器学习基础_损失函数.html">
<a href="机器学习基础_损失函数.html">
<b>1.2.6.</b>
                    
                    机器学习基础_损失函数
            
                </a>
</li>
</ul>
</li>
<li class="chapter" data-level="1.3" data-path="特征工程.html">
<a href="特征工程.html">
<b>1.3.</b>
                    
                    特征工程
            
                </a>
<ul class="articles">
<li class="chapter" data-level="1.3.1" data-path="特征工程_归一化.html">
<a href="特征工程_归一化.html">
<b>1.3.1.</b>
                    
                    特征工程_归一化
            
                </a>
</li>
<li class="chapter" data-level="1.3.2" data-path="特征工程_编码.html">
<a href="特征工程_编码.html">
<b>1.3.2.</b>
                    
                    特征工程_编码
            
                </a>
</li>
<li class="chapter" data-level="1.3.3" data-path="特征工程_特征组合.html">
<a href="特征工程_特征组合.html">
<b>1.3.3.</b>
                    
                    特征工程_特征组合
            
                </a>
</li>
<li class="chapter" data-level="1.3.4" data-path="特征工程_特征选择.html">
<a href="特征工程_特征选择.html">
<b>1.3.4.</b>
                    
                    特征工程_特征选择
            
                </a>
</li>
<li class="chapter" data-level="1.3.5" data-path="特征工程_文本表示模型.html">
<a href="特征工程_文本表示模型.html">
<b>1.3.5.</b>
                    
                    特征工程_文本表示模型
            
                </a>
</li>
<li class="chapter" data-level="1.3.6" data-path="特征工程_图像增强.html">
<a href="特征工程_图像增强.html">
<b>1.3.6.</b>
                    
                    特征工程_图像增强
            
                </a>
</li>
</ul>
</li>
<li class="chapter" data-level="1.4" data-path="模型评估.html">
<a href="模型评估.html">
<b>1.4.</b>
                    
                    模型评估
            
                </a>
<ul class="articles">
<li class="chapter" data-level="1.4.1" data-path="模型评估_评估指标.html">
<a href="模型评估_评估指标.html">
<b>1.4.1.</b>
                    
                    模型评估_评估指标
            
                </a>
</li>
<li class="chapter" data-level="1.4.2" data-path="模型评估_AB测试.html">
<a href="模型评估_AB测试.html">
<b>1.4.2.</b>
                    
                    模型评估_AB测试
            
                </a>
</li>
<li class="chapter" data-level="1.4.3" data-path="模型评估_过拟合和欠拟合.html">
<a href="模型评估_过拟合和欠拟合.html">
<b>1.4.3.</b>
                    
                    模型评估_过拟合和欠拟合
            
                </a>
</li>
<li class="chapter" data-level="1.4.4" data-path="模型评估_超参数选择.html">
<a href="模型评估_超参数选择.html">
<b>1.4.4.</b>
                    
                    模型评估_超参数选择
            
                </a>
</li>
<li class="chapter" data-level="1.4.5" data-path="模型评估_模型评估方法.html">
<a href="模型评估_模型评估方法.html">
<b>1.4.5.</b>
                    
                    模型评估_模型评估方法
            
                </a>
</li>
</ul>
</li>
<li class="chapter" data-level="1.5" data-path="降维.html">
<a href="降维.html">
<b>1.5.</b>
                    
                    降维
            
                </a>
<ul class="articles">
<li class="chapter" data-level="1.5.1" data-path="降维_PCA主成分分析.html">
<a href="降维_PCA主成分分析.html">
<b>1.5.1.</b>
                    
                    降维_PCA主成分分析
            
                </a>
</li>
<li class="chapter" data-level="1.5.2" data-path="降维_LDA线性判别分析.html">
<a href="降维_LDA线性判别分析.html">
<b>1.5.2.</b>
                    
                    降维_LDA线性判别分析
            
                </a>
</li>
</ul>
</li>
<li class="chapter" data-level="1.6" data-path="监督学习.html">
<a href="监督学习.html">
<b>1.6.</b>
                    
                    监督学习
            
                </a>
<ul class="articles">
<li class="chapter" data-level="1.6.1" data-path="监督学习_朴素贝叶斯分类.html">
<a href="监督学习_朴素贝叶斯分类.html">
<b>1.6.1.</b>
                    
                    监督学习_朴素贝叶斯分类
            
                </a>
</li>
<li class="chapter active" data-level="1.6.2" data-path="监督学习_决策树.html">
<a href="监督学习_决策树.html">
<b>1.6.2.</b>
                    
                    监督学习_决策树
            
                </a>
</li>
<li class="chapter" data-level="1.6.3" data-path="监督学习_K近邻法.html">
<a href="监督学习_K近邻法.html">
<b>1.6.3.</b>
                    
                    监督学习_K近邻法
            
                </a>
</li>
<li class="chapter" data-level="1.6.4" data-path="监督学习_支持向量机.html">
<a href="监督学习_支持向量机.html">
<b>1.6.4.</b>
                    
                    监督学习_支持向量机
            
                </a>
</li>
<li class="chapter" data-level="1.6.5" data-path="监督学习_CRF.html">
<a href="监督学习_CRF.html">
<b>1.6.5.</b>
                    
                    监督学习_CRF
            
                </a>
</li>
</ul>
</li>
<li class="chapter" data-level="1.7" data-path="非监督学习.html">
<a href="非监督学习.html">
<b>1.7.</b>
                    
                    非监督学习
            
                </a>
<ul class="articles">
<li class="chapter" data-level="1.7.1" data-path="非监督学习_K均值.html">
<a href="非监督学习_K均值.html">
<b>1.7.1.</b>
                    
                    非监督学习_K均值
            
                </a>
</li>
<li class="chapter" data-level="1.7.2" data-path="非监督学习_Mean Shift均值漂移聚类.html">
<a href="非监督学习_Mean Shift均值漂移聚类.html">
<b>1.7.2.</b>
                    
                    非监督学习_Mean Shift均值漂移聚类
            
                </a>
</li>
<li class="chapter" data-level="1.7.3" data-path="非监督学习_DBSCAN基于密度的聚类方法.html">
<a href="非监督学习_DBSCAN基于密度的聚类方法.html">
<b>1.7.3.</b>
                    
                    非监督学习_DBSCAN基于密度的聚类方法
            
                </a>
</li>
<li class="chapter" data-level="1.7.4" data-path="非监督学习_Hierarchical Clustering层次聚类.html">
<a href="非监督学习_Hierarchical Clustering层次聚类.html">
<b>1.7.4.</b>
                    
                    非监督学习_Hierarchical Clustering层次聚类
            
                </a>
</li>
<li class="chapter" data-level="1.7.5" data-path="非监督学习_Spectral Clustering谱聚类.html">
<a href="非监督学习_Spectral Clustering谱聚类.html">
<b>1.7.5.</b>
                    
                    非监督学习_Spectral Clustering谱聚类
            
                </a>
</li>
</ul>
</li>
<li class="chapter" data-level="1.8" data-path="半监督学习.html">
<a href="半监督学习.html">
<b>1.8.</b>
                    
                    半监督学习
            
                </a>
</li>
<li class="chapter" data-level="1.9" data-path="集成学习.html">
<a href="集成学习.html">
<b>1.9.</b>
                    
                    集成学习
            
                </a>
</li>
<li class="chapter" data-level="1.10" data-path="强化学习.html">
<a href="强化学习.html">
<b>1.10.</b>
                    
                    强化学习
            
                </a>
</li>
<li class="divider"></li>
<li>
<a class="gitbook-link" href="https://www.gitbook.com" target="blank">
            本书使用 GitBook 发布
        </a>
</li>
</ul>
</nav>
</div>
<div class="book-body">
<div class="body-inner">
<div class="book-header" role="navigation">
<!-- Title -->
<h1>
<i class="fa fa-circle-o-notch fa-spin"></i>
<a href="..">监督学习_决策树</a>
</h1>
</div>
<div class="page-wrapper" role="main" tabindex="-1">
<div class="page-inner">
<div class="search-plus" id="book-search-results">
<div class="search-noresults">
<section class="normal markdown-section">
<div id="anchor-navigation-ex-navbar"><i class="fa fa-navicon"></i><ul><li><span class="title-icon"></span><a href="#决策树decision-tree">1 决策树(Decision Tree)</a></li><li><span class="title-icon"></span><a href="#特征选择">2 特征选择</a></li><li><span class="title-icon"></span><a href="#id3—最大信息增益">3 ID3—最大信息增益</a></li><li><span class="title-icon"></span><a href="#c45—最大信息增益比">4 C4.5—最大信息增益比</a></li><li><span class="title-icon"></span><a href="#cart—最大基尼指数gini">5 CART—最大基尼指数(Gini)</a></li><li><span class="title-icon"></span><a href="#构造准则比较">6 构造准则比较</a></li><li><span class="title-icon"></span><a href="#剪枝操作">7 剪枝操作</a></li><ul><li><span class="title-icon"></span><a href="#预剪枝">7.1 预剪枝</a></li><li><span class="title-icon"></span><a href="#后剪枝">7.2 后剪枝</a></li><li><span class="title-icon"></span><a href="#cart剪枝">7.3 CART剪枝</a></li></ul></ul></div><a href="#决策树decision-tree" id="anchorNavigationExGoTop"><i class="fa fa-arrow-up"></i></a><p><a data-lightbox="ad84e2ca-c564-45ff-ae5a-42136528c5b5" data-title="异世界.png" href="res/other/异世界蕾姆_1.png"><img alt="异世界.png" src="res/other/异世界蕾姆_1.png"/></a></p>
<p><li><span class="title-icon"></span><a href="#决策树decision-tree">1 决策树(Decision Tree)</a></li><li><span class="title-icon"></span><a href="#特征选择">2 特征选择</a></li><li><span class="title-icon"></span><a href="#id3—最大信息增益">3 ID3—最大信息增益</a></li><li><span class="title-icon"></span><a href="#c45—最大信息增益比">4 C4.5—最大信息增益比</a></li><li><span class="title-icon"></span><a href="#cart—最大基尼指数gini">5 CART—最大基尼指数(Gini)</a></li><li><span class="title-icon"></span><a href="#构造准则比较">6 构造准则比较</a></li><li><span class="title-icon"></span><a href="#剪枝操作">7 剪枝操作</a></li><ul><li><span class="title-icon"></span><a href="#预剪枝">7.1 预剪枝</a></li><li><span class="title-icon"></span><a href="#后剪枝">7.2 后剪枝</a></li><li><span class="title-icon"></span><a href="#cart剪枝">7.3 CART剪枝</a></li></ul></p>
<h1 id="决策树decision-tree">1 决策树(Decision Tree)</h1>
<blockquote>
<p><code>决策树</code>是一种自上而下，对样本数据进行树形分类的过程，由结点和有向边组成。结点分为内部结点和叶结点，其中每个内部结点表示一个特征或属性，叶结点表示类别。从顶部根结点开始，所有样本聚在一起。经过根结点的划分，样本被分到不同的子结点中。再根据子结点的特征进一步划分，直至所有样本都被归到某一个类别(即叶结点)中。</p>
<p>决策树作为最基础、最常见的有监督学习模型，常被用于分类问题和回归问题，在市场营销和生物医药等领域尤其受欢迎，主要因为树形结构与销售、诊断等场景下的决策过程十分相似。将决策树应用集成学习的思想可以得到<code>随机森林、梯度提升决策树</code>等模型。</p>
<p>决策树的生成包含了<code>特征选择</code>、<code>树的构造</code>、<code>树的剪枝</code>三个过程</p>
<p><a data-lightbox="cb98816a-e69f-4e7c-9ac4-7557fa841b3a" data-title="img" href="res/Machine%20Learning%20Base/14638325-7063207f1274c675.webp"><img alt="img" src="res/Machine%20Learning%20Base/14638325-7063207f1274c675.webp"/></a></p>
</blockquote>
<h1 id="特征选择">2 特征选择</h1>
<blockquote>
<blockquote>
<p>特征选择在于选取对训练数据具有分类能力的特征。这样可以提高决策树学习的效率。</p>
<p>如果利用一个特征进行分类的结果与随机分类的结果没有很大差别，称这个特征是没有分类能力的。</p>
<p>经验上扔掉这样的特征对决策树学习的精度影响不大。</p>
<p>通常特征选择的准则是信息增益或信息增益比。</p>
<p><code>信息增益</code></p>
<p>在信息论与概率统计中，<code>熵(entropy)</code>是表示随机变量不确定性的度量。设X是一个取有限个值的离散随机变量，其概率分布为
<script type="math/tex; mode=display">
>>P(X=x_i)=p_i,i=1,2,...,n
>></script>
则随机变量<code>X</code>的熵定义为
<script type="math/tex; mode=display">
>>H(X)=-\sum_{i=1}^{n}{p_i \log (p_i)}
>></script>
在式中，若<script type="math/tex; ">p_i＝0</script>，则定义<script type="math/tex; ">0log0＝0</script>。</p>
<p>通常，式中的对数以2为底或以e为底(自然对数)，这时熵的单位分别称作比特(bit)或纳特(nat)。</p>
<p>由定义可知，熵只依赖于<script type="math/tex; ">X</script>的分布，而与<script type="math/tex; ">X</script>的取值无关，所以也可将<script type="math/tex; ">X</script>的熵记作<script type="math/tex; ">H(p)</script>，即
<script type="math/tex; mode=display">
>>H(p)=-\sum_{i=1}^{n}{p_i \log {(p_i)}}
>></script>
熵越大，随机变量的不确定性就越大。从定义可验证
<script type="math/tex; mode=display">
>>0 \leq H(p) \leq log(n)
>></script>
当随机变量只取两个值，例如1，0时，即X的分布为
<script type="math/tex; mode=display">
>>P(X=1)=p,P(X=0)=1-p,0 \leq p \leq 1
>></script>
熵为
<script type="math/tex; mode=display">
>>H(p)=-p \log_{2}{p}-(1-p) \log_2(1-p)
>></script>
这时，熵<script type="math/tex; ">H(p)</script>随概率<script type="math/tex; ">p</script>变化的曲线如图所示(单位为比特)。</p>
<p><a data-lightbox="f8b0120e-6f9b-43a0-934d-20dfc39bab44" data-title="1570026923638" href="res/Machine%20Learning%20Base/1570026923638.png"><img alt="1570026923638" src="res/Machine%20Learning%20Base/1570026923638.png"/></a></p>
<p>当<script type="math/tex; ">p＝0</script>或<script type="math/tex; ">p＝1</script>时<script type="math/tex; ">H(p)＝0</script>，随机变量完全没有不确定性。</p>
<p>当<script type="math/tex; ">p＝0.5</script>时，<script type="math/tex; ">H(p)＝1</script>，熵取值最大，随机变量不确定性最大。</p>
<p>设有随机变量<script type="math/tex; ">(X,Y)</script>，其联合概率分布为
<script type="math/tex; mode=display">
>>P(X=x_i,Y=y_i)=p_{ij},i=1,2,...,n;j=1,2,...,n
>></script>
<code>条件熵</code><script type="math/tex; ">H(Y|X)</script>表示在已知随机变量<script type="math/tex; ">X</script>的条件下随机变量<script type="math/tex; ">Y</script>的不确定性。</p>
<p>随机变量<script type="math/tex; ">X</script>给定的条件下随机变量<script type="math/tex; ">Y</script>的条件熵(conditional entropy)<script type="math/tex; ">H(Y|X)</script>，定义为<script type="math/tex; ">X</script>给定条件下<script type="math/tex; ">Y</script>的条件概率分布的熵对<script type="math/tex; ">X</script>的数学期望
<script type="math/tex; mode=display">
>>H(Y|X)=\sum_{i=1}^{n}{p_iH(Y|X=x_i)}
>></script>
这里，<script type="math/tex; ">p_i＝P(X＝x_i),i＝1,2,...,n</script>。</p>
<p>当熵和条件熵中的概率由数据估计(特别是极大似然估计)得到时，所对应的熵与条件熵分别称为<code>经验熵</code>(empirical entropy)和<code>经验条件熵</code>(empirical conditional entropy)。</p>
<p>此时，如果有0概率，令<script type="math/tex; ">0log0＝0</script>。</p>
<p><code>信息增益</code>(information gain)表示得知特征X的信息而使得类Y的信息的不确定性减少的程度。</p>
<p>特征<script type="math/tex; ">A</script>对训练数据集<script type="math/tex; ">D</script>的信息增益<script type="math/tex; ">g(D,A)</script>，定义为集合<script type="math/tex; ">D</script>的经验熵<script type="math/tex; ">H(D)</script>与特征<script type="math/tex; ">A</script>给定条件下<script type="math/tex; ">D</script>的经验条件熵<script type="math/tex; ">H(D|A)</script>之差，即
<script type="math/tex; mode=display">
>>g(D,A)=H(D)-H(D|A)
>></script>
一般地，熵<script type="math/tex; ">H(Y)</script>与条件熵<script type="math/tex; ">H(Y|X)</script>之差称为<code>互信息</code>(mutual information)。</p>
<p>决策树学习中的信息增益等价于训练数据集中类与特征的互信息。</p>
<p>对于数据集<script type="math/tex; ">D</script>而言，信息增益依赖于特征，不同的特征往往具有不同的信息增益。信息增益大的特征具有更强的分类能力。</p>
<p>根据信息增益准则的特征选择方法是：对训练数据集(或子集)<script type="math/tex; ">D</script>，计算其每个特征的信息增益，并比较它们的大小，选择信息增益最大的特征。</p>
<p><code>信息增益比</code></p>
<p>信息增益值的大小是相对于训练数据集而言的，并没有绝对意义。在分类问题困难时，也就是说在训练数据集的经验熵大的时候，信息增益值会偏大。反之，信息增益值会偏小。</p>
<p>使用<code>信息增益比</code>(information gain ratio)可以对这一问题进行校正。这是特征选择的另一准则。</p>
<p>信息增益比: 特征<script type="math/tex; ">A</script>对训练数据集<script type="math/tex; ">D</script>的信息增益比<script type="math/tex; ">g_R(D,A)</script>定义为其信息增益<script type="math/tex; ">g(D,A)</script>与训练数据集<script type="math/tex; ">D</script>的经验熵<script type="math/tex; ">H(D)</script>之比：
<script type="math/tex; mode=display">
>>g_R(D,A)=\frac{g(D,A)}{H(D)}
>></script></p>
</blockquote>
</blockquote>
<h1 id="id3—最大信息增益">3 ID3—最大信息增益</h1>
<blockquote>
<p>对于样本集合<script type="math/tex; ">D</script>，类别数为<script type="math/tex; ">K</script>，数据集<script type="math/tex; ">D</script>的经验熵表示为
<script type="math/tex; mode=display">
>H(D)=-\sum_{k=1}^{K}{\frac{|C_k|}{|D|} log_2{\frac{|C_k|}{|D|}}}
></script>
其中<script type="math/tex; ">C_k</script>是样本集合<script type="math/tex; ">D</script>中属于第<script type="math/tex; ">k</script>类的样本子集，<script type="math/tex; ">|C_k|</script>为该子集的元素个数，<script type="math/tex; ">|D|</script>为样本集合的元素个数。</p>
<p>然后计算某个特征<script type="math/tex; ">A</script>对于数据集<script type="math/tex; ">D</script>的经验条件熵为<script type="math/tex; ">H(D|A)</script>
<script type="math/tex; mode=display">
>H(D|A)=\sum_{i=1}^{n}{\frac{|D_i|}{|D|}H(D_i)}=\sum_{i=1}^{n}{\frac{|D_i|}{|D|}(-\sum_{k=1}^{K}{\frac{|D_{ik}|}{|D_i|}log_2{\frac{|D_{ik}|}{|D_i|}}})}
></script>
其中，<script type="math/tex; ">D_i</script>表示<script type="math/tex; ">D</script>中特征<script type="math/tex; ">A</script>取第<script type="math/tex; ">i</script>个值的样本子集，<script type="math/tex; ">D_{ik}</script>表示<script type="math/tex; ">D_i</script>中属于第<script type="math/tex; ">k</script>类的样本子集。</p>
<p>于是<code>信息增益</code><script type="math/tex; ">g(D,A)</script>可以表示为二者之差，可得
<script type="math/tex; mode=display">
>g(D,A)=H(D)-H(D|A)
></script></p>
<table>
<thead>
<tr>
<th>计数</th>
<th>年龄</th>
<th>收入</th>
<th>学生</th>
<th>信誉</th>
<th>是否购买</th>
</tr>
</thead>
<tbody>
<tr>
<td>64</td>
<td>青</td>
<td>高</td>
<td>否</td>
<td>良</td>
<td>不买</td>
</tr>
<tr>
<td>64</td>
<td>青</td>
<td>高</td>
<td>否</td>
<td>优</td>
<td>不买</td>
</tr>
<tr>
<td>128</td>
<td>中</td>
<td>高</td>
<td>否</td>
<td>良</td>
<td>买</td>
</tr>
<tr>
<td>60</td>
<td>老</td>
<td>中</td>
<td>否</td>
<td>良</td>
<td>买</td>
</tr>
<tr>
<td>64</td>
<td>老</td>
<td>低</td>
<td>是</td>
<td>良</td>
<td>买</td>
</tr>
<tr>
<td>64</td>
<td>老</td>
<td>低</td>
<td>是</td>
<td>优</td>
<td>不买</td>
</tr>
<tr>
<td>64</td>
<td>中</td>
<td>低</td>
<td>是</td>
<td>优</td>
<td>买</td>
</tr>
<tr>
<td>128</td>
<td>青</td>
<td>中</td>
<td>否</td>
<td>良</td>
<td>不买</td>
</tr>
<tr>
<td>64</td>
<td>青</td>
<td>低</td>
<td>是</td>
<td>良</td>
<td>买</td>
</tr>
<tr>
<td>132</td>
<td>老</td>
<td>中</td>
<td>是</td>
<td>良</td>
<td>买</td>
</tr>
<tr>
<td>64</td>
<td>青</td>
<td>中</td>
<td>是</td>
<td>优</td>
<td>买</td>
</tr>
<tr>
<td>32</td>
<td>中</td>
<td>中</td>
<td>否</td>
<td>优</td>
<td>买</td>
</tr>
<tr>
<td>32</td>
<td>中</td>
<td>高</td>
<td>是</td>
<td>良</td>
<td>买</td>
</tr>
<tr>
<td>64</td>
<td>老</td>
<td>中</td>
<td>否</td>
<td>优</td>
<td>不买</td>
</tr>
</tbody>
</table>
<p>有了上面的这些概念，我们就可以手工实现以下<script type="math/tex; ">ID3</script>算法的决策树生成过程。
(1) 计算对给定样本分类所需的信息熵。
   如表所示，类别标签<script type="math/tex; ">S</script>被分两类：买或不买。其中<script type="math/tex; ">S_1(买)=640</script>；<script type="math/tex; ">S_2(不买)=384</script>。
   那么总<script type="math/tex; ">S=S_1+S_2=1024</script>。</p>
<p>​    <script type="math/tex; ">S_1</script>的概率<script type="math/tex; ">p_1=640/1024=0.625</script>；<script type="math/tex; ">S_2</script>的概率<script type="math/tex; ">P_2=384/1024=0.375</script>。</p>
<p>​<br/><script type="math/tex; mode=display">
>I(S_1,S_2)=I(640,384)=-p_1log(p_1)-p_2log(p_2)\\
>=-(p_1log(p_1)+p_2log(p_2))=0.9544
></script>
(2)  计算每个特征的信息熵</p>
<p>​    <code>①</code> 先计算“年龄”特征的熵。</p>
<p>​    年龄共分三组：青年(0)、中年(1)、老年(2)。</p>
<p>​    其中青年占总样本的概率为：<script type="math/tex; ">p(0)=384/1024=0.375</script>；</p>
<p>​    青年中买/不买比例为：<script type="math/tex; ">128/256</script>， <script type="math/tex; ">S_1(买)=128</script>，<script type="math/tex; ">p_1=128/384</script>；<script type="math/tex; ">S_2(不买)=256</script>，<script type="math/tex; ">p_2=256/384</script>；    <script type="math/tex; ">S=S_1+S_2=384</script>。
​    根据公式：
<script type="math/tex; mode=display">
>I(S_1,S_2)=I(128,256)=0.9183
></script>
​    其中中年占总样本的概率为：<script type="math/tex; ">p(1)=256/1024=0.25</script>；中年买/不买比例为：<script type="math/tex; ">256/0</script>，<script type="math/tex; ">S_1(买）=256</script>，    <script type="math/tex; ">p_1=1</script>；<script type="math/tex; ">S_2(不买)=0</script>，<script type="math/tex; ">p_2=0</script>；<script type="math/tex; ">S=S_1+S_2=256</script>。
​    根据公式：
<script type="math/tex; mode=display">
>I(S_1,S_2)=I(256,0)=0
></script>
​    其中老年占总样本的概率为：<script type="math/tex; ">P(2)=384/1024=0.375</script>；老年买/不买比例为：<script type="math/tex; ">257/127</script>，</p>
<p>​    <script type="math/tex; ">S_1(买)=257</script>，<script type="math/tex; ">p_1=257/384</script>；<script type="math/tex; ">S_2(不买)=127</script>,<script type="math/tex; ">p_2=127/384</script>；<script type="math/tex; ">S=S_1+S_2=384</script>。
​    根据公式3.3：<br/><script type="math/tex; mode=display">
>I(S_1,S_2)=I(257,127)=0.9157
></script>
​    那么，年龄的平均信息期望： 
<script type="math/tex; mode=display">
>E(年龄)=0.375 \times 0.9183+0.25 \times 0+0.375 \times 0.9157=0.6877\\
>G(年龄)=0.9544-0.6877=0.2667
></script>
​    <code>②</code> 计算“学生”特征的熵。</p>
<p>​    学生共分两组：是(0)、否(1)。</p>
<p>​    学生的平均信息期望：<br/><script type="math/tex; mode=display">
>E(学生)=0.7811 \\
>G(学生)=0.9544-0.7811=0
>1733
></script>
<code>③</code> 计算“收入”特征的熵。</p>
<p>​    收入共分三组：高(0)、中(1)、低(2)。</p>
<p>​    收入的平均信息期望：<br/><script type="math/tex; mode=display">
>E(收入)=0.9361 \\
>G(收入)=0.9544-0.9361=0.0183
></script>
​    <code>④</code> 计算“信誉”特征的熵。</p>
<p>​    信誉共分两组：优(0)、良(1)。</p>
<p>​    信誉的平均信息期望： 
<script type="math/tex; mode=display">
>E(信誉)=0.9048 \\
>G(信誉)=0.9544-0.9048=0.0496
></script>
(3) 从所有的特征列中选出信息增益最大的那个作为根节点或内部节点—划分节点，划分整列，首次递归选择年龄列(<script type="math/tex; ">G=0.2667</script>)来划分。
(4) 根据划分节点的不同取值来拆分数据集为若干个子集，然后删去当前的特征列， 再计算剩余特征列的信息熵。如果有信息增益，就重复第二步直至划分结束。</p>
<p>首次划分 后，青年和老年内含有多个标签，所以可以继续划分；中年选项就只剩一个标签，就作为叶子节点。
(5) 划分结束的标志为：子集中只有一个类别标签，停止划分。
   按照这样的逻辑产生的决策树结果如图所示</p>
<p>​    <a data-lightbox="63ef8ffa-2ab6-41cb-997c-c4744288fb6b" data-title="1570033634957" href="res/Machine%20Learning%20Base/1570033634957.png"><img alt="1570033634957" src="res/Machine%20Learning%20Base/1570033634957.png"/></a></p>
<p>从图中可以看到，使用信息熵生成的决策树要比自己计算的决策树层数少。</p>
<p>如果数据集的特征很多，那么使用信息熵创建决策树在结构上要明显优于其他方法，可形成最优的决策树结构。</p>
<p>​    ID3算法是比较早的机器学习算法，在1979年Quinlan就提出了该算法的思想。它以信息熵为度量标准，划分出决策树特征节点，每次优先选取信息量最多的属性，也就是使信息熵变为最小的属性，以构造一棵信息熵下降最快的决策树。
<code>缺点</code></p>
<ol>
<li><p>ID3算法的节点划分度量标准采用的是信息增益，<code>信息增益偏向于选择特征值个数较多的特征</code>。</p>
<p>  而取值个数较多的特征并不一定是最优的特征，所以需要改进选择属性的节点划分度量标准。</p>
</li>
<li><p>ID3算法递归过程中需要依次计算每个特征值的，对于大型数据会生成比较复杂的决策树：层次和分支都很多，而其中某些分支的特征值概率很小，如果不加忽略就会造成过拟合的问题。即决策树对样本数据的分类精度较高，但在测试集上，分类的结果受决策树分支的影响很大。</p>
</li>
</ol>
</blockquote>
<h1 id="c45—最大信息增益比">4 C4.5—最大信息增益比</h1>
<blockquote>
<p>特征<script type="math/tex; ">A</script>对于数据集<script type="math/tex; ">D</script>的<code>信息增益比</code>定义为
<script type="math/tex; mode=display">
>g_R(D,A)=\frac{g(D,A)}{H_A(D)}
></script>
其中
<script type="math/tex; mode=display">
>H_A(D)=-\sum_{i=1}^{n}{\frac{|D_i|}{D}log_2{\frac{D_i}{D}}}
></script>
称为数据集<script type="math/tex; ">D</script>关于<script type="math/tex; ">A</script>的取值熵。</p>
<table>
<thead>
<tr>
<th></th>
<th>年龄</th>
<th>长相</th>
<th>工资</th>
<th>写代码</th>
<th>类别</th>
</tr>
</thead>
<tbody>
<tr>
<td>小A</td>
<td>老</td>
<td>帅</td>
<td>高</td>
<td>不会</td>
<td>不见</td>
</tr>
<tr>
<td>小B</td>
<td>年轻</td>
<td>一般</td>
<td>中等</td>
<td>会</td>
<td>见</td>
</tr>
<tr>
<td>小C</td>
<td>年轻</td>
<td>丑</td>
<td>高</td>
<td>不会</td>
<td>不见</td>
</tr>
<tr>
<td>小D</td>
<td>年轻</td>
<td>一般</td>
<td>高</td>
<td>会</td>
<td>见</td>
</tr>
<tr>
<td>小E</td>
<td>年轻</td>
<td>一般</td>
<td>高</td>
<td>不会</td>
<td>不见</td>
</tr>
</tbody>
</table>
<p>针对上述问题，我们可以求出数据集关于每个特征的取值熵为
<script type="math/tex; mode=display">
>H_{年龄}=-\frac{1}{5}log_2{\frac{1}{5}}-\frac{4}{5}log_2{\frac{4}{5}}=0.722 \\
>H_{长相}=-\frac{1}{5}log_2{\frac{1}{5}}-\frac{3}{5}log_2{\frac{3}{5}}-\frac{1}{5}log_2{\frac{1}{5}}=1.371 \\
>H_{工资}=-\frac{3}{5}log_2{\frac{3}{5}}-\frac{1}{5}log_2{\frac{1}{5}}-\frac{1}{5}log_2{\frac{1}{5}}=1.371 \\
>H_{写代码}=-\frac{3}{5}log_2{\frac{3}{5}}-\frac{2}{5}log_2{\frac{2}{5}}=0.971
></script>
于是可计算出各个特征的信息增益比为
<script type="math/tex; mode=display">
>g_R(D,年龄)=0.236 \\
>g_R(D,长相)=0.402 \\
>g_R(D,工资)=0.402 \\
>g_R(D,写代码)=1
></script>
信息增益比最大的是特征“写代码”，但通过信息增益比，特征“年龄”对应的指标上升了，而特征“长相”和特征“工资”却有所下降。</p>
<ul>
<li><strong>缺点</strong>：信息增益比偏向取值较少的特征</li>
<li><strong>原因</strong>： 当特征取值较少时HA(D)的值较小，因此其倒数较大，因而信息增益比较大。因而偏向取值较少的特征。</li>
<li><strong>使用信息增益比</strong>：基于以上缺点，并不是直接选择信息增益率最大的特征，而是现在候选特征中找出信息增益高于平均水平的特征，然后在这些特征中再选择信息增益率最高的特征。</li>
</ul>
</blockquote>
<h1 id="cart—最大基尼指数gini">5 CART—最大基尼指数(Gini)</h1>
<blockquote>
<p>Gini描述的是数据的纯度，与信息熵含义类似。
<script type="math/tex; mode=display">
>Gini(D)=1-\sum_{k=1}^{n}{(\frac{|C_k|}{|D|})^2}
></script>
CART在每一次迭代中选择基尼指数最小的特征及其对应的切分点进行分类。但与ID3、C4.5不同的是，CART是一颗二叉树，采用二元切割法，每一步将数据按特征<em>A</em>的取值切成两份，分别进入左右子树。特征<em>A</em>的Gini指数定义为
<script type="math/tex; mode=display">
>Gini(D|A)=\sum_{i=1}^{n}{\frac{|D_i|}{|D|}}Gini(D_i)
></script>
还是考虑上述的例子，应用CART分类准则，根据式（3.24）可计算出各个特征的Gini指数为
<script type="math/tex; mode=display">
>Gini(D|年龄=老)=0.4, Gini(D|年龄=年轻)=0.4, \\
>Gini(D|长相=帅)=0.4, Gini(D|长相=丑)=0.4, \\
>Gini(D|写代码=会)=0, Gini(D|写代码=不会)=0, \\
>Gini(D|工资=高)=0.47, Gini(D|工资=中等)=0.3, \\
>Gini(D|工资=低)=0.4
></script>
在“年龄”“长相”“工资”“写代码”四个特征中，我们可以很快地发现特征“写代码”的Gini指数最小为0，因此选择特征“写代码”作为最优特征，“写代码=会”为最优切分点。按照这种切分，从根结点会直接产生两个叶结点，基尼指数降为0，完成决策树生长。</p>
</blockquote>
<h1 id="构造准则比较">6 构造准则比较</h1>
<blockquote>
<p>通过对比三种决策树的构造准则，以及在同一例子上的不同表现，我们不难总结三者之间的差异。</p>
<p>首先，ID3是采用信息增益作为评价标准，除了“会写代码”这一逆天特征外，会倾向于取值较多的特征。因为，信息增益反映的是给定条件以后不确定性减少的程度，特征取值越多就意味着确定性更高，也就是条件熵越小，信息增益越大。这在实际应用中是一个缺陷。比如，我们引入特征“DNA”，每个人的DNA都不同，如果ID3按照“DNA”特征进行划分一定是最优的（条件熵为0），但这种分类的泛化能力是非常弱的。因此，C4.5实际上是对ID3进行优化，通过引入信息增益比，一定程度上对取值比较多的特征进行惩罚，避免ID3出现过拟合的特性，提升决策树的泛化能力。</p>
<p>其次，从样本类型的角度，ID3只能处理离散型变量，而C4.5和CART都可以处理连续型变量。C4.5处理连续型变量时，通过对数据排序之后找到类别不同的分割线作为切分点，根据切分点把连续属性转换为布尔型，从而将连续型变量转换多个取值区间的离散型变量。而对于CART，由于其构建时每次都会对特征进行二值划分，因此可以很好地适用于连续性变量。</p>
<p>从应用角度，ID3和C4.5只能用于分类任务，而CART（Classification and Regression Tree，分类回归树）从名字就可以看出其不仅可以用于分类，也可以应用于回归任务（回归树使用最小平方误差准则）。</p>
<p>此外，从实现细节、优化过程等角度，这三种决策树还有一些不同。比如，ID3对样本特征缺失值比较敏感，而C4.5和CART可以对缺失值进行不同方式的处理；ID3和C4.5可以在每个结点上产生出多叉分支，且每个特征在层级之间不会复用，而CART每个结点只会产生两个分支，因此最后会形成一颗二叉树，且每个特征可以被重复使用；ID3和C4.5通过剪枝来权衡树的准确性与泛化能力，而CART直接利用全部数据发现所有可能的树结构进行对比。</p>
<p>至此，我们从构造、应用、实现等角度对比了ID3、C4.5、CART这三种经典的决策树模型。这些区别与联系总结起来容易，但在实际应用中还需要读者慢慢体会，针对不同场景灵活变通。</p>
</blockquote>
<h1 id="剪枝操作">7 剪枝操作</h1>
<blockquote>
<p>决策树生成算法递归地产生决策树，直到不能继续下去为止。这样产生的树往往对训练数据的分类很准确，但对未知的测试数据的分类却没有那么准确，即出现过拟合现象。</p>
<p>在决策树学习中将已生成的树进行简化的过程称为剪枝（pruning）。具体地，剪枝从已生成的树上裁掉一些子树或叶结点，并将其根结点或父结点作为新的叶结点，从而简化分类树模型，提升模型的泛化能力。</p>
<p>决策树的剪枝往往通过极小化决策树整体的损失函数(loss function)或代价函数(cost function)来实现。</p>
<p>设树<script type="math/tex; ">T</script>的叶结点个数为<script type="math/tex; ">|T|</script>，<script type="math/tex; ">t</script>是树<script type="math/tex; ">T</script>的叶结点，该叶结点有<script type="math/tex; ">N_t</script> 个样本点，其中<script type="math/tex; ">k</script>类的样本点有<script type="math/tex; ">N_{tk}</script>个，<script type="math/tex; ">k＝1,2,...,K</script>，<script type="math/tex; ">H_t(T)</script>为叶结点<script type="math/tex; ">t</script>上的经验熵，<script type="math/tex; ">a \geq 0</script>为参数，则决策树学习的损失函数可以定义为
<script type="math/tex; mode=display">
>C_a(T)=\sum_{t=1}^{|T|}{N_tH_t(T)+\alpha|T|}
></script>
其中经验熵为
<script type="math/tex; mode=display">
>H_t(T)=-\sum_{k}{\frac{N_{tk}}{N_t}log{\frac{N_{tk}}{N_t}}}
></script>
在损失函数中，将式右端的第1项记作
<script type="math/tex; mode=display">
>C(T)=\sum_{t=1}^{|T|}{N_tH_t(T)}=-\sum_{t=1}^{|T|}{\sum_{k=1}^{K}{ N_{tk}log{\frac{N_{tk}}{N_t}} }}
></script>
这时有
<script type="math/tex; mode=display">
>C_{\alpha}(T)=C(T)+\alpha|T|
></script>
式中，<script type="math/tex; ">C(T)</script>表示模型对训练数据的预测误差，即模型与训练数据的拟合程度，<script type="math/tex; ">|T|</script>表示模型复杂度，参数<script type="math/tex; "> \alpha \geq 0</script>控制两者之间的影响。</p>
<p>较大的<script type="math/tex; "> \alpha</script>促使选择较简单的模型(树)，</p>
<p>较小的<script type="math/tex; "> \alpha</script>促使选择较复杂的模型(树)。</p>
<p><script type="math/tex; "> \alpha=0</script>意味着只考虑模型与训练数据的拟合程度，不考虑模型的复杂度。</p>
<p>剪枝，就是当<script type="math/tex; "> \alpha</script>确定时，选择损失函数最小的模型，即损失函数最小的子树。</p>
<p>当<script type="math/tex; "> \alpha</script>值确定时，子树越大，往往与训练数据的拟合越好，但是模型的复杂度就越高；相反，子树越小，模型的复杂度就越低，但是往往与训练数据的拟合不好。损失函数正好表示了对两者的平衡。</p>
<p>可以看出，决策树生成只考虑了通过提高信息增益(或信息增益比)对训练数据进行更好的拟合。</p>
<p>而决策树剪枝通过优化损失函数还考虑了减小模型复杂度。</p>
<p>决策树生成学习局部的模型，而决策树剪枝学习整体的模型。</p>
<p>定义的损失函数的极小化等价于正则化的极大似然估计。所以，利用损失函数最小原则进行剪枝就是用正则化的极大似然估计进行模型选择</p>
<p><a data-lightbox="9278acab-603c-4060-b98a-e0f183f93ed0" data-title="1570064604418" href="res/Machine%20Learning%20Base/1570064604418.png"><img alt="1570064604418" src="res/Machine%20Learning%20Base/1570064604418.png"/></a></p>
<p>决策树的剪枝通常有两种方法，<code>预剪枝</code>(Pre-Pruning)和<code>后剪枝</code>(Post-Pruning)。</p>
</blockquote>
<h2 id="预剪枝">7.1 预剪枝</h2>
<blockquote>
<p><code>预剪枝</code>的核心思想是在树中结点进行扩展之前，先计算当前的划分是否能带来模型泛化能力的提升，如果不能，则不再继续生长子树。此时可能存在不同类别的样本同时存于结点中，按照多数投票的原则判断该结点所属类别。预剪枝对于何时停止决策树的生长有以下几种方法。</p>
<ol>
<li>当树到达一定深度的时候，停止树的生长。</li>
<li>当到达当前结点的样本数量小于某个阈值的时候，停止树的生长。</li>
<li>计算每次分裂对测试集的准确度提升，当小于某个阈值的时候，不再继续扩展。</li>
</ol>
<p>预剪枝具有思想直接、算法简单、效率高等特点，适合解决大规模问题。但如何准确地估计何时停止树的生长（即上述方法中的深度或阈值），针对不同问题会有很大差别，需要一定经验判断。</p>
<p>且预剪枝存在一定局限性，有欠拟合的风险，虽然当前的划分会导致测试集准确率降低，但在之后的划分中，准确率可能会有显著上升。</p>
</blockquote>
<h2 id="后剪枝">7.2 后剪枝</h2>
<blockquote>
<p><code>后剪枝</code>的核心思想是让算法生成一棵完全生长的决策树，然后从最底层向上计算是否剪枝。</p>
<p>剪枝过程将子树删除，用一个叶子结点替代，该结点的类别同样按照多数投票的原则进行判断。同样地，后剪枝也可以通过在测试集上的准确率进行判断，如果剪枝过后准确率有所提升，则进行剪枝。</p>
<p>相比于预剪枝，后剪枝方法通常可以得到泛化能力更强的决策树，但<code>时间开销会更大</code>。</p>
<p>常见的后剪枝方法包括<code>错误率降低剪枝</code>(Reduced Error Pruning，REP)、<code>悲观剪枝</code>(Pessimistic Error Pruning，PEP)、<code>代价复杂度剪枝</code>(Cost Complexity Pruning，CCP)、<code>最小误差剪枝</code>(Minimum Error Pruning，MEP)、<code>CVP</code>(Critical Value Pruning)、<code>OPP</code>(Optimal Pruning)等方法，这些剪枝方法各有利弊，关注不同的优化角度。</p>
</blockquote>
<h2 id="cart剪枝">7.3 CART剪枝</h2>
<blockquote>
<p>CART的<code>代价复杂剪枝CCP</code></p>
<p>代价复杂剪枝主要包含以下两个步骤。</p>
<ol>
<li>从完整决策树<script type="math/tex; ">T_0</script>开始，生成一个子树序列<script type="math/tex; ">\{T_0,T_1,*,...,T_n\}</script>，其中<script type="math/tex; ">T_{i+1}</script>由<script type="math/tex; ">T_i</script>生成，<script type="math/tex; ">T_n</script>为根节点。</li>
<li>在子树序列中，根据真实误差选择最佳的决策树。</li>
</ol>
<p><code>步骤1</code>从<script type="math/tex; ">T_0</script>开始，裁剪中<script type="math/tex; ">T_i</script>关于训练数据集合误差增加最小的分支以得到<script type="math/tex; ">T_{i+1}</script>。</p>
<p>具体地，当一棵树<script type="math/tex; ">T</script>在结点<script type="math/tex; ">t</script>处剪枝时，它的误差增加可以用<script type="math/tex; ">R(t)−R(T_t)</script>表示，其中<script type="math/tex; ">R(t)</script>表示进行剪枝之后的该结点误差，<script type="math/tex; ">R(T_t)</script>表示未进行剪枝时子树<script type="math/tex; ">T_t</script>的误差。</p>
<p>考虑到树的复杂性因素，我们用<script type="math/tex; ">|L(T_t)|</script>表示子树<script type="math/tex; ">T_t</script>的叶子结点个数，则树在结点<script type="math/tex; ">t</script>处剪枝后的误差增加率为
<script type="math/tex; mode=display">
>\alpha = \frac{R(t)-R(T_t)}{|L(T_t)|-1}
></script>
在得到<script type="math/tex; ">T_i</script>后，我们每步选择<script type="math/tex; "> \alpha</script>最小的结点进行相应剪枝。</p>
<p>用一个例子简单地介绍生成子树序列的方法。</p>
<p>假设把场景中的问题进行一定扩展，女孩需要对80个人进行见或不见的分类。</p>
<p>假设根据某种规则，已经得到了一棵CART决策树<script type="math/tex; ">T_0</script>，如图所示</p>
<p><a data-lightbox="fef3e240-c188-4860-9407-a03f3c775337" data-title="1570066823030" href="res/Machine%20Learning%20Base/1570066823030.png"><img alt="1570066823030" src="res/Machine%20Learning%20Base/1570066823030.png"/></a></p>
<p>此时共5个内部结点可供考虑，其中
<script type="math/tex; mode=display">
>a(t_0)=\frac{25-5}{6-1}=4, \\
>a(t_1)=\frac{10-(1+2+0+0)}{4-1}=2.33, \\
>a(t_2)=\frac{5-(1+1)}{2-1}=3, \\
>a(t_3)=\frac{4-(1+2)}{2-1}=1, \\
>a(t_4)=\frac{4-0}{2-1}=4
></script>
可见<script type="math/tex; ">\alpha (t_3)</script>最小，因此对进<script type="math/tex; ">t_3</script>进行剪枝，得到新的子树<script type="math/tex; ">T_1</script>，如图所示。</p>
<p><a data-lightbox="74081ac9-4c9f-4ece-95d5-2437b81c5df8" data-title="1570067096451" href="res/Machine%20Learning%20Base/1570067096451.png"><img alt="1570067096451" src="res/Machine%20Learning%20Base/1570067096451.png"/></a></p>
<p>而后继续计算所有结点对应的误差增加率，分别为<script type="math/tex; ">\alpha(t_1)=3</script>，<script type="math/tex; ">\alpha(t_2)=3</script>，<script type="math/tex; ">\alpha(t_4)=4</script>。因此对<script type="math/tex; ">t_1</script>进行剪枝，得到<script type="math/tex; ">T_2</script>，如图所示。</p>
<p><a data-lightbox="11e88225-2917-4887-9dea-9327cc0528e0" data-title="1570067433218" href="res/Machine%20Learning%20Base/1570067433218.png"><img alt="1570067433218" src="res/Machine%20Learning%20Base/1570067433218.png"/></a></p>
<p>此时<script type="math/tex; ">\alpha (t_0)=6.5</script>，<script type="math/tex; ">\alpha (t_2)=3</script>，选择<script type="math/tex; ">t_2</script>进行剪枝，得到<script type="math/tex; ">T_3</script>。</p>
<p>于是只剩下一个内部结点，即根结点，得到<script type="math/tex; ">T_4</script>。</p>
<p>在<code>步骤2</code>中，我们需要从子树序列中选出真实误差最小的决策树。</p>
<p>CCP给出了两种常用的方法：</p>
<ol>
<li>一种是基于独立剪枝数据集，该方法与REP类似，但由于其只能从子树序列<script type="math/tex; ">\{ T_0,T_1,...,T_n \}</script>中选择最佳决策树，而非像REP能在所有可能的子树中寻找最优解，因此性能上会有一定不足。</li>
<li>另一种是基于<script type="math/tex; ">k</script>折交叉验证，将数据集分成<script type="math/tex; ">k</script>份，前<script type="math/tex; ">k−1</script>份用于生成决策树，最后一份用于选择最优的剪枝树。重复进行<script type="math/tex; ">N</script>次，再从这<script type="math/tex; ">N</script>个子树中选择最优的子树。</li>
</ol>
<p><code>代价复杂度剪枝</code>使用交叉验证策略时，不需要测试数据集，精度与REP差不多，但形成的树复杂度小。</p>
<p>而从算法复杂度角度，由于生成子树序列的时间复杂度与原始决策树的非叶结点个数呈二次关系，导致算法相比REP、PEP、MEP等线性复杂度的后剪枝方法，运行<code>时间开销更大</code>。</p>
</blockquote>
<p></p><footer class="page-footer"><span class="copyright">Copyright © narutohyc.com 2020 all right reserved，powered by Gitbook</span><span class="footer-modification">该文件修订时间：
2022-02-18 01:01:33
</span></footer><hr/><div id="vcomments"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({el: "#vcomments",appId: 'jQTfSSGRF0zp8yqaaa6bjeVQ-gzGzoHsz',appKey: 'FOXMptWOHC7cU1FxXt0LJj4o',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false})</script><p></p>
</section>
</div>
<div class="search-results">
<div class="has-results">
<h1 class="search-results-title"><span class="search-results-count"></span> results matching "<span class="search-query"></span>"</h1>
<ul class="search-results-list"></ul>
</div>
<div class="no-results">
<h1 class="search-results-title">No results matching "<span class="search-query"></span>"</h1>
</div>
</div>
</div>
</div>
</div>
</div>
<a aria-label="Previous page: 监督学习_朴素贝叶斯分类" class="navigation navigation-prev" href="监督学习_朴素贝叶斯分类.html">
<i class="fa fa-angle-left"></i>
</a>
<a aria-label="Next page: 监督学习_K近邻法" class="navigation navigation-next" href="监督学习_K近邻法.html">
<i class="fa fa-angle-right"></i>
</a>
</div>
<script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"监督学习_决策树","level":"1.6.2","depth":2,"next":{"title":"监督学习_K近邻法","level":"1.6.3","depth":2,"path":"chapters/监督学习_K近邻法.md","ref":"chapters/监督学习_K近邻法.md","articles":[]},"previous":{"title":"监督学习_朴素贝叶斯分类","level":"1.6.1","depth":2,"path":"chapters/监督学习_朴素贝叶斯分类.md","ref":"chapters/监督学习_朴素贝叶斯分类.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-sharing","splitter","expandable-chapters-small","anchors","github","github-buttons","donate","sharing-plus","anchor-navigation-ex","mathjax","mermaid-gb3","tbfed-pagefooter","code","favicon","search-plus","-lunr","-search","lightbox","change_girls","theme-comscore","valine","pageview-count","favicon-absolute"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"tbfed-pagefooter":{"copyright":"Copyright © narutohyc.com 2020","modify_label":"该文件修订时间：","modify_format":"YYYY-MM-DD HH:mm:ss"},"github":{"url":"https://github.com/narutohyc"},"splitter":{},"change_girls":{"time":10,"urls":["https://plc.jj20.com/up/allimg/1115/012122143136/220121143136-2.jpg","https://plc.jj20.com/up/allimg/1115/111R1094405/21111P94405-1.jpg"]},"sharing-plus":{"qq":false,"all":["facebook","google","twitter","instapaper","linkedin","pocket","stumbleupon"],"douban":false,"facebook":true,"weibo":false,"instapaper":false,"whatsapp":false,"hatenaBookmark":false,"twitter":true,"messenger":false,"line":false,"vk":false,"pocket":true,"google":false,"viber":false,"stumbleupon":false,"qzone":false,"linkedin":false},"code":{"copyButtons":true},"donate":{"alipay":"https://i.loli.net/2021/01/12/Cdunm9AoBcHF5MI.png","alipayText":"alipay打赏","button":"欢迎打赏","title":"","wechat":"https://i.loli.net/2021/01/12/gmzASfCciIFXTyr.png","wechatText":"wechat打赏"},"favicon-absolute":{"appleTouchIconMore":{},"appleTouchIconPrecomposed152":"./chapters/res/other/favicon.ico","appleTouchIconPrecomposedMore":{},"favicon":"./chapters/res/other/favicon.ico"},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"mermaid-gb3":{},"anchor-navigation-ex":{"associatedWithSummary":true,"float":{"floatIcon":"fa fa-navicon","level1Icon":"","level2Icon":"","level3Icon":"","showLevelIcon":false},"mode":"float","multipleH1":true,"pageTop":{"level1Icon":"","level2Icon":"","level3Icon":"","showLevelIcon":false},"printLog":false,"showGoTop":true,"showLevel":false},"favicon":{"shortcut":"https://upload-images.jianshu.io/upload_images/15675864-5e5ba668035853d8.png","bookmark":"https://upload-images.jianshu.io/upload_images/15675864-5e5ba668035853d8.png","appleTouch":"https://upload-images.jianshu.io/upload_images/15675864-5e5ba668035853d8.png","appleTouchMore":{"120x120":"https://upload-images.jianshu.io/upload_images/15675864-5e5ba668035853d8.png","180x180":"https://upload-images.jianshu.io/upload_images/15675864-5e5ba668035853d8.png"}},"lightbox":{"jquery":true,"sameUuid":false},"theme-comscore":{},"pageview-count":{},"github-buttons":{"buttons":[{"user":"narutohyc","repo":"bk_machineLearning","type":"star","size":"small","count":true}]},"mathjax":{"forceSVG":false,"version":"2.6-latest"},"expandable-chapters-small":{},"sharing":{"qq":true,"all":["google","facebook","weibo","twitter","qq","qzone","linkedin","pocket"],"douban":true,"facebook":true,"weibo":true,"instapaper":false,"whatsapp":false,"hatenaBookmark":false,"twitter":true,"messenger":false,"line":false,"vk":false,"pocket":false,"google":true,"viber":false,"stumbleupon":false,"qzone":true,"linkedin":false},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":true},"anchors":{},"valine":{"avatar":"","lang":"zh-CN","pageSize":10,"placeholder":"Just go go","recordIP":false,"appId":"jQTfSSGRF0zp8yqaaa6bjeVQ-gzGzoHsz","appKey":"FOXMptWOHC7cU1FxXt0LJj4o"},"search-plus":{}},"theme":"default","author":"narutohyc","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"机器学习相关学习记录","language":"zh-hans","links":{"sidebar":{"我的狗窝":"https://github.com/narutohyc"}},"gitbook":"*","description":"记录 机器学习 的学习和一些技巧的使用"},"file":{"path":"chapters/监督学习_决策树.md","mtime":"2022-02-18T01:01:33.662Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2022-02-18T01:03:17.262Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>
<script src="../gitbook/gitbook.js"></script>
<script src="../gitbook/theme.js"></script>
<script src="../gitbook/gitbook-plugin-splitter/splitter.js"></script>
<script src="../gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.js"></script>
<script src="../gitbook/gitbook-plugin-github/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-github-buttons/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-donate/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-sharing-plus/buttons.js"></script>
<script src="https://cdn.mathjax.org/mathjax/2.6-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src="../gitbook/gitbook-plugin-mathjax/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-mermaid-gb3/book/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-code/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-search-plus/jquery.mark.min.js"></script>
<script src="../gitbook/gitbook-plugin-search-plus/search.js"></script>
<script src="../gitbook/gitbook-plugin-lightbox/js/lightbox.min.js"></script>
<script src="../gitbook/gitbook-plugin-change_girls/girls.js"></script>
<script src="../gitbook/gitbook-plugin-pageview-count/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
<script src="../gitbook/gitbook-plugin-theme-comscore/test.js"></script>
<script src="../gitbook/gitbook-plugin-mermaid-gb3/mermaid/mermaid.min.js"></script>
</body>
</html>
